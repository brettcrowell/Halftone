<!DOCTYPE html>
<html>
  <head>
    <title>Halftone demo</title>
    <link rel="stylesheet" href="./assets/normalize.css" />
    <link rel="stylesheet" href="./assets/main.css" />
    <style>
      /* begin demo embedded styles */

      /* end demo embedded styles */
    </style>
  </head>
  <body>
    <h1>Halftone demo</h1>

    <!-- begin demo markup -->

    <div id="viewport"></div>

    Total Frame Time: <span id="total"></span><br/>
    Render Time: <span id="render"></span><br/>
    Max FPS: <span id="fps"></span><br/>
    Non-Render Time: <span id="nonrender"></span><br/>
    - Image Data: <span id="image"></span><br/>
    - Encoder: <span id="encode"></span><br/>
    - Compressor: <span id="compress"></span><br/>

    <!-- end demo markup -->

    <p>See the <a href="http://brettcrowell.github.io/Halftone">project homepage</a>.
    <p>Check out the <a href="https://github.com/brettcrowell/Halftone">project repo</a>.
    <p>Copyright 2014 Brett Crowell</p>

    <script src="../bower_components/getUserMedia/dist/getUserMedia.js"></script>
    <script src="./../dist/Halftone.js"></script>

    <script>
      /* begin demo script */

      // source (video, image on canvas)
      // frame encoder (inp: canvas, encodes in fps, event when frame ready)
      // client/decoder (displays hex matrix... svg, canvas, webgl?)
      // memoize everything!!!!!
      // base36
      // calculate similarity based on grayscale
      // offset encoding
      // compressor

      // max frame rate = 1 / ((21+19)/1000)

      // source --> encode --> compress --> decompress/renderer/display

      var cache = {

        virtualDOM: [],
        currentMatrix: [],
        maxLumens: 0,
        minLumens: 15

      }

      var source = new Halftone.WebcamSource();
        encoder = new Halftone.RasterFrameEncoder(),
        compressor = new Halftone.Compressor(),
        renderer = new Halftone.CachedCanvasRenderer();

      document.getElementById('viewport').appendChild(renderer.getElement());

      var frameInterval = 1 / (Halftone.Options.frameRate / 1000),
        resolution = Halftone.Options.resolution;

      var lastKnownFrame = null;

      var metrics = {
        renderTimes: [],
        totalTimes: [],
        imageTimes: [],
        encodeTimes: [],
        compressTimes: []
      };

      function displayMetrics(renderTime, totalTime, imageTime, encodeTime, compressTime){

        metrics.totalTimes.push(totalTime);
        var averageTime = Halftone.Util.average(metrics.totalTimes);

        metrics.renderTimes.push(renderTime);
        var averageRenderTime = Halftone.Util.average(metrics.renderTimes);

        metrics.imageTimes.push(imageTime);
        var averageImageTime = Halftone.Util.average(metrics.imageTimes);

        metrics.encodeTimes.push(encodeTime);
        var averageEncodeTime = Halftone.Util.average(metrics.encodeTimes);

        metrics.compressTimes.push(compressTime);
        var averageCompressTime = Halftone.Util.average(metrics.compressTimes);

        /*document.getElementById('total').textContent = parseInt(averageTime);
        document.getElementById('render').textContent = parseInt(averageRenderTime);
        document.getElementById('fps').textContent = parseInt(1000 / averageTime);
        document.getElementById('nonrender').textContent = parseInt(averageTime - averageRenderTime);
        document.getElementById('image').textContent = parseInt(averageImageTime);
        document.getElementById('encode').textContent = parseInt(averageEncodeTime);
        document.getElementById('compress').textContent = parseInt(averageCompressTime);*/


      }

      function updateFrame(){

        var totalBegin = new Date().getTime();

        var imageBegin = new Date().getTime();
        var imageData = source.getFrame();
        var imageTime = new Date().getTime() - imageBegin;

        var frameBegin = new Date().getTime();
        var currentFrame = encoder.encodeFrame(imageData, Halftone.Options.stagger);
        var frameTime = new Date().getTime() - frameBegin;

        var compressBegin = new Date().getTime();
        var differenceMatrix = (lastKnownFrame === null) ? currentFrame : compressor.getDifferenceMatrix(lastKnownFrame, currentFrame);
        var compressTime = new Date().getTime() - compressBegin;

        var renderBegin = new Date().getTime();

        renderer.render(differenceMatrix);

        var renderTime = new Date().getTime() - renderBegin,
          totalTime = new Date().getTime() - totalBegin;

        displayMetrics(renderTime, totalTime, imageTime, frameTime, compressTime);

        lastKnownFrame = currentFrame;

        // Object.keys(differenceMatrix.matrix).map(function(c){ return differenceMatrix.matrix[c].length; }).reduce(function(a,b){ return a + b })

      }

      setInterval(updateFrame, frameInterval)

      /* end demo script */
    </script>
  </body>
</html>
